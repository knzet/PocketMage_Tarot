name: Creare et Publicare Inscriptorem per Rete

on:
  push:
    branches: [ main ]
  workflow_dispatch:
  release:
    types: [published]

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  creare_et_publicare:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: Code/PocketMage_V3

    steps:
      - name: Checkout release tag
        if: github.event_name == 'release'
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.release.tag_name }}
          fetch-depth: 0

      - name: Checkout main
        if: ${{ github.event_name != 'release' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare the Python Cauldron
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Summon PlatformIO, esptool & jq
        run: |
          set -euo pipefail
          pip install -U platformio esptool
          sudo apt-get update
          sudo apt-get install -y jq rsync

      - name: Forge the PocketMage Firmware
        run: |
          set -euo pipefail
          pio run -e PM_V3
          echo "Build directory contents:"
          ls -lh .pio/build/PM_V3/*.bin

      - name: Divine Partition Offsets
        id: offsets
        run: |
          set -euo pipefail
          
          # Read offsets from partition CSV (expect 0x-prefixed hex or decimal)
          APP0_OFFSET=$(grep "^app0," partitions_4APP.csv | cut -d',' -f4 | tr -d ' ')
          PARTITIONS_OFFSET="0x8000"  # Standard for ESP32
          
          echo "bootloader_offset=0x0" >> $GITHUB_OUTPUT
          echo "partitions_offset=$PARTITIONS_OFFSET" >> $GITHUB_OUTPUT
          echo "app0_offset=$APP0_OFFSET" >> $GITHUB_OUTPUT
          
          echo "Partition offsets:"
          echo "  Bootloader: 0x0"
          echo "  Partitions: $PARTITIONS_OFFSET"
          echo "  App0: $APP0_OFFSET"

      - name: Determine the Flash Sigils (parameters)
        id: flash_params
        run: |
          set -euo pipefail
          
          # Extract flash mode and freq from platformio.ini or use sensible defaults for ESP32-S3
          FLASH_MODE="dio"
          FLASH_FREQ="80m"
          FLASH_SIZE="16MB"
          
          echo "flash_mode=$FLASH_MODE" >> $GITHUB_OUTPUT
          echo "flash_freq=$FLASH_FREQ" >> $GITHUB_OUTPUT
          echo "flash_size=$FLASH_SIZE" >> $GITHUB_OUTPUT
          
          echo "Flash parameters: mode=$FLASH_MODE freq=$FLASH_FREQ size=$FLASH_SIZE"

      - name: Scribe the Firmware Manifest
        run: |
          set -euo pipefail

          # Retrieve release tag (empty when not triggered by release event)
          RELEASE_TAG="${{ github.event.release.tag_name }}"

          # Use timestamped dev version for non-release builds
          if [ -z "$RELEASE_TAG" ]; then
            RELEASE_TAG="dev-$(date +%Y%m%d-%H%M%S)"
          fi

          BUILD_DIR="$GITHUB_WORKSPACE/Code/PocketMage_V3/.pio/build/PM_V3"
          TARGET_DIR="$GITHUB_WORKSPACE/docs/firmware/${RELEASE_TAG}"
          mkdir -p "${TARGET_DIR}"

          # Copy all firmware files
          cp "${BUILD_DIR}/firmware.bin" "${TARGET_DIR}/firmware.bin"
          cp "${BUILD_DIR}/bootloader.bin" "${TARGET_DIR}/bootloader.bin"
          cp "${BUILD_DIR}/partitions.bin" "${TARGET_DIR}/partitions.bin"

          echo "Firmware files copied to ${TARGET_DIR}"

          # Get partition offsets from previous step
          PARTITIONS_OFFSET="${{ steps.offsets.outputs.partitions_offset }}"
          APP0_OFFSET_HEX="${{ steps.offsets.outputs.app0_offset }}"

          # Convert hex (0x...) or decimal to decimal using bash arithmetic expansion
          to_decimal() {
            local v="$1"
            # strip whitespace
            v=$(echo "$v" | tr -d '[:space:]')
            if [[ "$v" =~ ^0x ]] || [[ "$v" =~ ^0X ]]; then
              # arithmetic expansion handles 0x### format
              echo $((v))
            else
              # if it's already decimal or empty, echo as-is (ensure numeric)
              if [[ -z "$v" ]]; then
                echo 0
              else
                echo $((v))
              fi
            fi
          }

          PARTITIONS_OFFSET_DEC=$(to_decimal "$PARTITIONS_OFFSET")
          APP0_OFFSET_DEC=$(to_decimal "$APP0_OFFSET_HEX")

          echo "Offsets: Partitions=${PARTITIONS_OFFSET} (${PARTITIONS_OFFSET_DEC}), App=${APP0_OFFSET_HEX} (${APP0_OFFSET_DEC})"

          # Create a single manifest with all parts
          jq -n \
            --arg ver "$RELEASE_TAG" \
            --argjson part_off "$PARTITIONS_OFFSET_DEC" \
            --argjson app_off "$APP0_OFFSET_DEC" \
            '{
              name: "PocketMage OS",
              version: $ver,
              home_assistant_domain: "",
              new_install_prompt_erase: true,
              builds: [{
                chipFamily: "ESP32-S3",
                parts: [
                  {
                    path: "bootloader.bin",
                    offset: 0
                  },
                  {
                    path: "partitions.bin",
                    offset: $part_off
                  },
                  {
                    path: "firmware.bin",
                    offset: $app_off
                  }
                ]
              }]
            }' > "${TARGET_DIR}/manifest.json"

          echo "Created manifest file for version: $RELEASE_TAG"

          # Ensure docs folder exists (important)
          mkdir -p "$GITHUB_WORKSPACE/docs"

          # Update or create version index (local docs copy)
          INDEX_FILE="$GITHUB_WORKSPACE/docs/manifest-index.json"
          if [ -f "${INDEX_FILE}" ]; then
            jq --arg v "$RELEASE_TAG" '
              def uniq_preserve: reduce .[] as $i ([]; if index($i)==null then . + [$i] else . end);
              ([$v] + (.versions // [])) | uniq_preserve | {versions: .}
            ' "${INDEX_FILE}" > "${INDEX_FILE}.tmp"
            mv "${INDEX_FILE}.tmp" "${INDEX_FILE}"
          else
            jq -n --arg v "$RELEASE_TAG" '{versions: [$v]}' > "${INDEX_FILE}"
          fi

          echo "Updated manifest-index.json with version: $RELEASE_TAG"
          echo "manifest-index.json content (local docs):"
          cat "$INDEX_FILE"

      - name: Write the Deploy Info Scroll
        run: |
          set -euo pipefail
          mkdir -p "$GITHUB_WORKSPACE/docs"

          # prefer release tag when available; fall back to dev timestamp
          RELEASE_TAG="${{ github.event.release.tag_name }}"
          if [ -z "$RELEASE_TAG" ]; then
            RELEASE_TAG="dev-$(date +%Y%m%d-%H%M%S)"
          fi

          jq -n \
            --arg release_tag "$RELEASE_TAG" \
            --arg run_id "$GITHUB_RUN_ID" \
            --arg run_number "$GITHUB_RUN_NUMBER" \
            --arg sha "$GITHUB_SHA" \
            --arg timestamp "$(date --utc +%Y-%m-%dT%H:%M:%SZ)" \
            '{release_tag: $release_tag, run_id: $run_id, run_number: $run_number, sha: $sha, timestamp: $timestamp}' \
            > "$GITHUB_WORKSPACE/docs/deploy-info.json"

          echo "Wrote deploy-info.json:"
          cat "$GITHUB_WORKSPACE/docs/deploy-info.json"

      - name: Prepare gh-pages tree (merge, remove old dev-* only)
        run: |
          set -euo pipefail

          GH_PAGES_DIR="$GITHUB_WORKSPACE/gh-pages"
          mkdir -p "$GH_PAGES_DIR"

          REPO_URL="https://github.com/${GITHUB_REPOSITORY}.git"
          echo "Checking if gh-pages branch exists on remote..."
          if git ls-remote --heads "$REPO_URL" gh-pages | grep -q refs/heads/gh-pages; then
            echo "Cloning existing gh-pages branch..."
            git clone --depth=1 --branch gh-pages "$REPO_URL" "$GH_PAGES_DIR"
          else
            echo "gh-pages branch does not exist; creating a fresh tree"
            mkdir -p "$GH_PAGES_DIR"
            git -C "$GH_PAGES_DIR" init
          fi

          # Remove previous dev-* firmware directories only (we want to keep released versions)
          if [ -d "$GH_PAGES_DIR/firmware" ]; then
            echo "Removing old dev-* firmware dirs from gh-pages (if any)..."
            find "$GH_PAGES_DIR/firmware" -maxdepth 1 -type d -name 'dev-*' -print -exec rm -rf {} +
          fi

          # Copy new docs into the gh-pages tree without deleting existing release folders
          echo "Copying new docs into gh-pages tree (rsync will overwrite but not remove other release dirs)..."
          rsync -a --delete --exclude='.git' "$GITHUB_WORKSPACE/docs/" "$GH_PAGES_DIR/"

          # Merge manifest-index.json:
          # Goal: preserve released versions, keep only the current dev-* (if current tag is dev-...)
          RELEASE_TAG="${{ github.event.release.tag_name }}"
          if [ -z "$RELEASE_TAG" ]; then
            RELEASE_TAG="dev-$(date +%Y%m%d-%H%M%S)"
          fi
          echo "Merging manifest-index.json on gh-pages (ensure releases persist). RELEASE_TAG=$RELEASE_TAG"

          MANIFEST="$GH_PAGES_DIR/manifest-index.json"
          TMP="$GH_PAGES_DIR/manifest-index.json.tmp"

          # If manifest exists on gh-pages use it, otherwise start from an empty array
          if [ -f "$MANIFEST" ]; then
            echo "Found existing manifest on gh-pages, merging..."
            cat "$MANIFEST" | jq --arg v "$RELEASE_TAG" '
              # keep only non-dev (released) versions from the existing list
              (.versions // []) | map(select(test("^dev-")|not)) as $releases |
              # prepend current release/dev and preserve first occurrence order (uniq_preserve)
              ([$v] + $releases) as $merged |
              reduce $merged[] as $i ([]; if index($i)==null then . + [$i] else . end) | {versions: .}
            ' > "$TMP"
          else
            echo "No existing manifest on gh-pages, creating from RELEASE_TAG"
            echo '{"versions":[]}' | jq --arg v "$RELEASE_TAG" '
              ([$v] + (.versions // [])) | reduce .[] as $i ([]; if index($i)==null then . + [$i] else . end) | {versions: .}
            ' > "$TMP"
          fi

          mv "$TMP" "$MANIFEST"
          echo "Merged manifest-index.json (gh-pages):"
          cat "$MANIFEST"

          # Show final tree for debugging
          echo "Final gh-pages tree (top-level):"
          ls -la "$GH_PAGES_DIR"
          echo "Final firmware dirs on gh-pages:"
          ls -la "$GH_PAGES_DIR/firmware" || true

      - name: Debug
        run: |
          set -euo pipefail
          echo "Contents of prepared gh-pages dir (preview):"
          find "$GITHUB_WORKSPACE/gh-pages" -maxdepth 2 -type f -print | sed -n '1,200p' || true
          echo "--- manifest-index.json ---"
          cat "$GITHUB_WORKSPACE/gh-pages/manifest-index.json" || true
          echo "--- deploy-info.json ---"
          cat "$GITHUB_WORKSPACE/gh-pages/deploy-info.json" || true

      - name: Deploy to gh-pages (peaceiris/actions-gh-pages)
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ${{ github.workspace }}/gh-pages
          commit_message: "[ci skip] chore(pages): deploy docs from run ${{ github.run_number }} (${GITHUB_SHA})"
